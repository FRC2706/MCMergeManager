package ca.team2706.scouting.mcmergemanager;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import Jama.*;

import ca.team2706.scouting.mcmergemanager.datamodels.BallShot;
import ca.team2706.scouting.mcmergemanager.datamodels.MatchData;
import ca.team2706.scouting.mcmergemanager.datamodels.MatchSchedule;

/**
 * Created by mike on 04/02/16.
 */
public class StatsEngine {

    public class TeamStatsReport implements Serializable {

        // Overall Stats
        public int    teamNo;
        public int    numMatchesPlayed;
        public int    wins;
        public int    losses;
        public int    ties;
        public double ORP;
        public double DPR;
        // could also include CCWM, and PMR, see http://www.chiefdelphi.com/media/papers/2174
        public double scheduleToughness;

        // Auto Stats
        public int numTimesReachedInAuto;
        public int numTimesBreachedInAuto;
        public int numTimesSpyBot;
        public int numSuccHighShotsInAuto;
        public int numSuccLowShotsInAuto;
        public int numFailedHighShotsInAuto;
        public int nemFailedLowShotsInAuto;

        // Teleop Stats
        public List<BallShot> missedTeleopShots;     // to draw pins on map
        public List<BallShot> successfulTeleopShots; // to draw pins on map
        public int    numSuccHighShotsInTeleop;
        public int    numSuccLowShotsInTeleop;
        public int    numFailedHighShotsInTeleop;
        public int    numFailedLowShotsInTeleop;
        public double avgHighShotTime;
        public double avgLowShotTime;
        public double avgTimeSpendPlayingDef;
        public int    numSuccPickupsFromGround;
        public int    numSuccPickupsFromWall;
        public int    numFailedPickups;
        public int    numTimesChallenged;
        public double avgDeadness;  // an int representing % of match spent wich mech problems
        public double heighestDeadness;

        /** Counts of how many times they've successfully breached each defense.
         * Note that this is an array of 9 items where the 0th item is not used. **/
        public int[] defensesBreached;

        // Scaling
        public int    numSuccessfulScales;
        public int    numFailedScales;
        public double avgScaleTime;


        // house keeping
        public MatchSchedule teamMatches;

        /** Private constructor so that it can only be generated by a StatsEngine instance **/
        private TeamStatsReport() {

        }

    }






    /** Class Stats Engine **/

    private MatchData matchData;
    private MatchSchedule matchSchedule;

    /** Contructor **/
    public StatsEngine(MatchData matchData, MatchSchedule matchSchedule) {
        this.matchData = matchData;
        this.matchSchedule = matchSchedule;
    }

    /** This constructor meant more for testing than for actual use **/
    public StatsEngine(MatchSchedule matchSchedule) {
        this.matchSchedule = matchSchedule;

        computeOPRs();
    }


    /**
     * Fill in a TeamStatsReport about the given team.
     */
    public TeamStatsReport getTeamStatsReport(int teamNo) {
        TeamStatsReport teamStatsReport = new TeamStatsReport();

        fillInOverallStats(teamStatsReport, teamNo);

        return teamStatsReport;
    }





    // mapping team numbers to various stats
    private Map<Integer, Double> OPRs;
    private Map<Integer, Double> DPRs;
    private Map<Integer, WLT> records;  // need for computation of schedule toughness


    private class WLT {
        int wins;
        int losses;
        int ties;
    }

    public Map<Integer, Double> getOPRs() {
        return OPRs;
    }

    /** Do some linear algebra to compute Offensive Power Rating for each team. **/
    private void computeOPRs() {
        if ( matchSchedule == null)
            return;


        // First, build the participation matrix
        // ie which matches did which team participate in.
        // Only include matches that we have a score for.

        // Figure out what the axis are for our matrix
        ArrayList<Integer> teams = new ArrayList<>();
        HashMap<Integer, Integer> blueScores = new HashMap<>();  // map of match #'s to scores
        HashMap<Integer, Integer> redScores = new HashMap<>();  // map of match #'s to scores

        for(MatchSchedule.Match match : matchSchedule.getMatches()) {
            if (match.getBlueScore() != -1) {
                blueScores.put(match.getMatchNo(), match.getBlueScore());

                if (!teams.contains(match.getBlue1()))
                    teams.add(match.getBlue1());

                if (!teams.contains(match.getBlue2()))
                    teams.add(match.getBlue2());

                if (!teams.contains(match.getBlue3()))
                    teams.add(match.getBlue3());
            }

            if (match.getRedScore() != -1) {
                redScores.put(match.getMatchNo(), match.getRedScore());

                if (! teams.contains(match.getRed1()) )
                    teams.add(match.getRed1());

                if (! teams.contains(match.getRed2()) )
                    teams.add(match.getRed2());

                if (! teams.contains(match.getRed3()) )
                    teams.add(match.getRed3());
            }
        }

        // sort all arrays and use position in array as indices into the matrix
        ArrayList<Integer> blueMatcheNos = new ArrayList<>(blueScores.keySet());
        ArrayList<Integer> redMatcheNos = new ArrayList<>(redScores.keySet());

        Collections.sort(teams);
        Collections.sort(blueMatcheNos);
        Collections.sort(redMatcheNos);

        int offset = blueScores.size();

        // build the matrix
        // This is a participation matrix with the matches in the first axis, and teams in the second.
        // If a team has participated in a match, that cell gets a 1, otherwise it gets a 0.
        // Note that we treat the blue and red alliances as if they were playing completely seperate matches for the sake of OPR.
        double[][] Mdbl = new double[blueScores.size()+redScores.size()][teams.size()];
        double[] allScores = new double[blueScores.size()+redScores.size()];

        for(MatchSchedule.Match match : matchSchedule.getMatches()) {
            if (match.getBlueScore() != -1) {
                int matchNoIdx = blueMatcheNos.indexOf(match.getMatchNo());
                Mdbl[matchNoIdx][ teams.indexOf(match.getBlue1()) ] = 1;
                Mdbl[matchNoIdx][ teams.indexOf(match.getBlue2()) ] = 1;
                Mdbl[matchNoIdx][ teams.indexOf(match.getBlue3()) ] = 1;

                allScores[matchNoIdx] = match.getBlueScore();
            }

            if (match.getRedScore() != -1) {
                int matchNoIdx = blueMatcheNos.indexOf(match.getMatchNo()) + offset;
                Mdbl[matchNoIdx][ teams.indexOf(match.getRed1()) ] = 1;
                Mdbl[matchNoIdx][ teams.indexOf(match.getRed2()) ] = 1;
                Mdbl[matchNoIdx][ teams.indexOf(match.getRed3()) ] = 1;

                allScores[matchNoIdx] = match.getRedScore();
            }
        }

        Matrix M = new Matrix(Mdbl);
        Matrix Y = new Matrix(allScores, allScores.length);

        Matrix MatOPRs = M.transpose().times(M).inverse().times(M.transpose()).times(Y);


        // now that we have the data, fill in the hashmap
        OPRs = new HashMap<>();
        for(int i=0; i<teams.size(); i++) {
            OPRs.put(teams.get(i), MatOPRs.get(i, 0));
        }



    }


    public List<MatchData.Match> getMatchesForTeam(int teamNo) {
        List<MatchData.Match> matches = new ArrayList<>();

        for(MatchData.Match match : matchData.matches) {
            if (match.preGame.teamNumber == teamNo)
                matches.add(match);
        }
        return matches;
    }

    public List<BallShot> getMissedTeleopShotsByTeam(int teamNo) {

        List<BallShot> missedShots = new ArrayList<>();

        for(MatchData.Match match : getMatchesForTeam(teamNo)) {
            for(BallShot shot : match.teleopMode.ballsShot) {
                if (shot.whichGoal == shot.MISS)
                    missedShots.add(shot);
            }
        }

        return missedShots;
    }

    public List<BallShot> getSuccessfulTeleopShotsByTeam(int teamNo) {

        List<BallShot> succShots = new ArrayList<>();

        for(MatchData.Match match : getMatchesForTeam(teamNo) ) {
            for(BallShot shot : match.teleopMode.ballsShot) {
                if (shot.whichGoal == shot.HIGH_GOAL || shot.whichGoal == shot.LOW_GOAL)
                    succShots.add(shot);
            }
        }

        return succShots;
    }


    /**
     * This includes both auto and teleop breaches.
     *
     * @return an array of 8 ints holding the counts. The constants in TeleopScoutindObject can be used as indices to this array.
     *
     * Note that this is an array of 9 items where the 0th item is not used.
     */
    public int[] getNumberOfBreaches(int teamNo) {
        int[] breaches = new int[8];

        for(MatchData.Match match : getMatchesForTeam(teamNo) ) {
            // combine auto and teleop
            List<Integer> bs = match.autoMode.defensesBreached;
            bs.addAll(match.teleopMode.defensesBreached);

            for(Integer breach : bs) {
                breaches[breach]++;
            }
        }

        return breaches;
    }

    /**
     *
     * // Overall Stats
     * public int    teamNo;
     * public int    numMatchesPlayed;
     * public int    wins;
     * public int    losses;
     * public int    ties;
     * public double ORP;
     * public double DPR;
     * public double scheduleToughness;
     */
    private void fillInOverallStats(TeamStatsReport teamStatsReport, int teamNo) {
        teamStatsReport.teamNo = teamNo;

        if (teamStatsReport.teamMatches == null)
            teamStatsReport.teamMatches = matchSchedule.filterByTeam(teamNo);

        teamStatsReport.numMatchesPlayed = teamStatsReport.teamMatches.getMatches().size();

    }

}
